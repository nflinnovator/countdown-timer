/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.nfl;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressIndicator;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;

import static java.util.concurrent.Executors.newSingleThreadExecutor;
import static javafx.geometry.Pos.CENTER;

public final class App extends Application {

    public static final Duration DEFAULT_DURATION = Duration.ofMinutes(1), DEFAULT_PERIOD = Duration.ofSeconds(1);
    private long countdownId;
    private final Map<String, Map<String, Object>> countdownsRepository = new HashMap<>();
    private final ExecutorService executorService = newSingleThreadExecutor();
    private Map<String, Object> createNewCountdownProcessStateValue = initial();
    private Node createNewCountdownView = createNewCountdownViewValue(createNewCountdownProcessStateValue);
    private final Pane countdownTimerView = countdownTimerView(createNewCountdownView);
    private final Consumer<Map<String, Object>> createNewCountdownProcessStateValueChangeConsumer = (stateValue) -> Platform.runLater(() -> {
        countdownTimerView.getChildren().remove(createNewCountdownView);
        createNewCountdownView = createNewCountdownViewValue(stateValue);
        countdownTimerView.getChildren().add(createNewCountdownView);
    });

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Countdown Timer");
        primaryStage.setMaximized(true);
        final Parent page = homePage(countdownTimerView);
        primaryStage.setScene(new Scene(page));
        primaryStage.show();
    }

    @Override
    public void stop() {
        executorService.shutdown();
    }

    public Node createNewCountdownViewValue(Map<String, Object> stateValue) {
        if (Objects.equals("initial", stateValue.get("type"))) {
            final var view = new Button("Create New Countdown");
            view.setOnAction((event -> executorService.execute(this::onCreateNewCountdown)));
            return view;
        } else if (Objects.equals("running", stateValue.get("type"))) {
            final var view = new VBox(new ProgressIndicator(), new Label("Creating a new countdown..."));
            view.setAlignment(CENTER);
            view.setSpacing(10);
            return view;
        } else if (Objects.equals("completed", stateValue.get("type"))) {
            if (Objects.equals("success", value(stateValue, "data", "result"))) {
                final var view = new Button("Create New Countdown");
                view.setOnAction((event -> executorService.execute(this::onCreateNewCountdown)));
                return view;
            }
        }
        return new Label("Error Invalid State Value : " + stateValue);
    }

    public void onCreateNewCountdown() {
        createNewCountdownProcessStateValue = running();
        createNewCountdownProcessStateValueChangeConsumer.accept(createNewCountdownProcessStateValue);
        final var countdown = countdown(++countdownId, DEFAULT_DURATION, DEFAULT_PERIOD);
        wait(Duration.ofSeconds(new Random().nextInt(1, 10)));
        final var wasSuccessfullySaved = countdownsRepository.put(value(countdown, "data", "id").toString(), countdown);
        if (!Objects.equals(wasSuccessfullySaved, countdown)) {
            createNewCountdownProcessStateValue = completed("success", countdown);
            createNewCountdownProcessStateValueChangeConsumer.accept(createNewCountdownProcessStateValue);
        }
    }

    public static Map<String, Object> initial() {
        return Map.of("type", "initial", "data", Map.of());
    }

    public static Map<String, Object> running() {
        return Map.of("type", "running", "data", Map.of());
    }

    public static Map<String, Object> completed(String result, Map<String, Object> countdownToBeCreated) {
        return Map.of("type", "completed", "data", Map.of("result", result, "countdown", countdownToBeCreated));
    }

    public static Map<String, Object> countdown(long id, Duration duration, Duration period) {
        return Map.of("name", "countdown", "type", "", "data", countdownData(id, duration, period));
    }

    public static Map<String, Object> countdownData(long id, Duration duration, Duration period) {
        return Map.of("id", id, "duration", duration, "period", period, "status", "off");
    }

    public static Pane countdownTimerView(Node... children) {
        final var root = new VBox(children);
        root.setAlignment(CENTER);
        root.setSpacing(20);
        return root;
    }

    public static Parent homePage(Node child) {
        final var root = new VBox(child);
        root.setAlignment(CENTER);
        return root;
    }

    public static Object value(Map<String, Object> map, String... path) {
        Object value = map;
        for (String key : path) {
            if (value instanceof Map<?, ?>) {
                value = ((Map<?, ?>) value).get(key);
            }
        }
        return value;
    }

    public static void wait(Duration duration) {
        try {
            Thread.sleep(duration.toMillis());
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }


}
